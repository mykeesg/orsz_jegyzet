\documentclass[12pt]{article}

%margins
\usepackage[a4paper,
inner = 25mm,
outer = 25mm,
top = 25mm,
bottom = 25mm]{geometry}

\usepackage{lmodern}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx} %elte logo
\usepackage{amssymb}
\usepackage{amsmath} % \text{}, \substack{} in math mode
\usepackage{setspace} %spacing
\usepackage{enumerate} %enum as a)b)c)
\usepackage{nameref} %referencing chapters with names


\newcommand{\lfsih}[1] {$\lceil lf(S,#1) \rceil$}
\newcommand{\sprog}{$S \subseteq A \times A^{**} $}


\setstretch{1.2}
\begin{document}
	
	\begin{titlepage}
		\vspace*{0cm}
		\centering
		\begin{tabular}{cp{1cm}c}
			\begin{minipage}{4cm}
				\vspace{0pt}
				\includegraphics[width=1\textwidth]{elte_cimer}
			\end{minipage} & &
			\begin{minipage}{7cm}
				\vspace{0pt}Eötvös Loránd Tudományegyetem \vspace{10pt} \newline
				Informatikai Kar \vspace{10pt} \newline
				Programozási Nyelvek és Fordítóprogramok Tanszék
			\end{minipage}
		\end{tabular}
		
		\vspace*{0.2cm}
		\rule{\textwidth}{1pt}
		
		\vspace*{3cm}
		{\Huge Osztott rendszerek szintézise }
		
		\vspace*{0.5cm}
		{\normalsize IPM-08sztORSZE}
		
		\vspace{2cm}
		{\huge Konzultációs segédanyag}
		
		\vspace*{5cm}
		
		{\large \verb|Kopácsi László, Szabó Miklós|}
		
		\vfill
		
		\vspace*{1cm}
		Utolsó módosítás: \today
	\end{titlepage}
	
	\tableofcontents
	\newpage
	
	\section{konzultáció}
		\subsection{Áttekintés}
		\paragraph{}
		Az előadás során több, temporális logikai relációval találkoztunk, nézzük ezeket át informálisan, kezdve a biztonsági tulajdonságokkal.
		
	\begin{itemize}
		\item 
		Az első, melyet ''háromszög''-ként említünk ($ \vartriangleright $), bizonyos állapot-átmeneteket megenged, másokat pedig megtilt. A $(P \vartriangleright Q)$ azt jelenti, hogy a $P$ állapotot \textbf{ha} elhagyjuk, akkor ezt csak a $Q$-n keresztül tehetjük meg. A háromszög azonban nem tesz semmiféle kikötést arról, hogy a $P$-t el kell hagynunk, csupán biztosít minket arról, hogy ha ez mégis megtörténik, akkor milyen irányba (nem) mozdulhatunk.
		
		\item Másik biztonsági tulajdonság az \textit{invariáns}. Ha egy $K$ állítás invariáns, akkor ennek minden állapot-átmenet előtt és után teljesülnie kell.
		
		\item A harmadik említett kikötés a \textit{fixpont}. Ezzel leírhatjuk, hogy ha egy rendszerben már nem figyelhetünk meg további állapot-átmeneteket, akkor milyen tulajdonságoknak kell teljesülnie. $(FP \Rightarrow R)$ estén például egy $R$-el jelölt állítás igaz, amennyiben fixpontba jutottunk. Fixpontba azonban nem csak a kívánt befejezési állapot tartozhat, ha holtpont helyzet alakul ki, azt is tekinthetjük fixpontnak.
	\end{itemize}
	Természetesen nem csak biztonsági tulajdonságokra van szükségünk - azaz mit (ne) csinálhasson a rendszer -, hanem haladásira is (azért csináljon valamit).
	
	\begin{itemize}
		\item Az ''egyenes nyíl'' ($\mapsto$) néven nevezett reláció egy szigorú kikötés arra vonatkozóan, hogy egy állapotból milyen másik helyzetbe \textbf{kell} lépnünk. Míg $\vartriangleright$ esetén csupán azt mondtuk, hogy \textit{ha} elhagyunk egy állapotot, akkor azt milyen irányba tegyük, a $(P \mapsto Q)$ azt mondja, hogy a $P$ állapotból a $Q$ állapotba kell, hogy kerüljünk (véges időn belül).
		\item Ennél megengedőbb a ''görbe nyíl''-ként ($\hookrightarrow$) ismert reláció. Ebben az esetben a $(A \hookrightarrow B)$ feltétel csupán annyit mond, hogy az $A$ állapotot előbb-utóbb a $B$ állapot fogja követni (azaz $A$-ból elkerülhetetlenül $B$-be fogunk érkezni), de itt nincs semmilyen megkötés arra, hogy a két állapot egymás után következzen be. Legális állapot-átmenet sorozat az $(A \hookrightarrow B)$-ra az $<A, G, F, D, F, E, C, D, B>$ is.
	\end{itemize}

\subsection{Étkező filozófusok}\label{etkezo-filo}
	Tekintsük az előadáson is ismertetett \textit{étkező filozófusok} feladatot (jegyzet\textsuperscript{\cite{orsi_jegyzet}} 1.1). Próbáljuk meg kiegészíteni a feltételeket további megkötések formalizálásával:
	\begin{itemize}
		\item Ha a rendszer nyugalmi állapotban van, akkor egy filozófus sem eszik.
		\item Mindegyik filozófusra igaz, hogy ha hazament, akkor utána már nem kerülhet más állapotba.
	\end{itemize}

\subsection{Moziterem}\label{moziterem-feladat}
	A következő példában egy mozira vonatkozó feladatot fogunk ismertetni, ahol a nézők tevékenységére szeretnénk megkötéseket tenni. A jelölést megkönnyítendő vezessük be az alábbiakat: $n(i)$ jelölje az $i$-ik nézőt. A moziba látogatók állapotait az alábbiak alapján jelöljük:
	\begin{enumerate}[a)]
		\item megérkezik a moziba - a
		\item jegyet vesz - j
		\item üdítőt és nasit vásárol - b
		\item érvényes jeggyel rendelkezik - t
		\item filmet néz - f
		\item hazamegy - h
	\end{enumerate}
	Próbáljuk formalizálni az alábbi feltételeket:
	\begin{itemize}
		\item A moziba érkező néző filmet fog nézni.
		\item Ha valaki érvényes jeggyel rendelkezik, akkor megnézi a filmet.
		\item Ha a moziban nincs mozgás, akkor minden néző már otthon van.
		\item A moziba érkező néző jegyet vásárol, vagy a büfébe megy.
		\item A film után a néző hazamegy.
		\item Senki nem nézhet filmet úgy, hogy nincs érvényes jegye. (Tipp: próbáljunk invariánst megfogalmazni.)
		\item Ha valaki hazament, akkor már nem csinál semmit a moziban.
	\end{itemize}

\newpage
\section{konzultáció}
\subsection{Áttekintés}
Ahhoz, hogy a későbbiekben biztos módon számolhassunk programokkal , elkerülhetetlen a számunkra szükséges (alap)fogalmakat tisztázni a halmazelmélet és a relációk témakörében.

Legyenek $A$ és $B$ tetszőleges halmazok. $A$ és $B$ \textit{direkt-}, vagy \textit{Descartes}-szorzatán azt a halmazt értjük, melyben olyan párok találhatóak, melynek első eleme $A$-, második eleme pedig $B$-beli.
$$A \times B ::= \{ (a,b) | a \in A \text{ és } b \in B \}$$
Jelölje $r \subseteq A \times B$ azt a bináris relációt, mely $A$ elemeihez rendel értékeket a $B$ halmazból ($A$ és $B$ tetszőleges halmazok). A reláció elemeit $(a,b) \in r $ módon fogjuk jelölni.
$$ \text{Az } r \text{ reláció értelmezési tartománya: } \mathcal{D}_r = \{a \in A | \exists b \in B: (a,b) \in r \} \subseteq A$$
$$ \text{Az } r \text{ reláció értékkészlete: } \mathcal{R}_r = \{b \in B | \exists a \in A: (a,b) \in r \} \subseteq B$$
$$\ r(a) \text{ jelölje azt a halmazt, melynek elemei: } \{b \in B | (a,b) \in r \} $$

Világos, hogy az értelmezési tartományban olyan elemek vannak, amikhez rendel valamit $r$, míg az értékkészletben olyanokat találhatunk, amik valamilyen elemhez hozzá lettek rendelve. Egy elem képe a hozzá rendelt elemek halmazából áll elő.

Egy $g$ relációt \textit{parciális függvény}nek (vagy determinisztikus relációnak) nevezhetünk, amennyiben az alábbi teljesül:
$$\forall a \in A : |g(a)| \le 1,$$ azaz minden elemhez \textit{legfeljebb} egy másikat társítunk.
Jelölésünk ekkor: $g \in A \rightarrow B$.
Ha minden elemhez pontosan egy értéket rendelünk, akkor az $f$ reláció függvény, azaz:
$$\forall a \in A : |f(a)| = 1. $$
Jelölésünk ekkor: $ f: A \rightarrow B $. Ebben az esetben általában $f(a)$ nem az egy elemű halmazt, hanem annak képét jelenti.

Ahhoz, hogy állításokat fogalmazhassunk meg a későbbiekben, szükségünk lesz logikai relációkra is.
$$\text{A } h \subseteq A \times \mathbb{L} \text{ logikai relációnak nevezzük, ahol } \mathbb{L} ::= \{igaz, hamis\}.$$
Ha $h$ függvény, akkor \textit{logikai függvény}nek nevezzük.\\
Egy reláció inverzét az alábbi módon definiálhatjuk:
$$R^{(-1)} ::= \{(b,a) \in B \times A | (a,b) \in R  \}$$

A továbbiakban szükségünk lesz egy reláció adott halmazra vonatkozó inverz- és őskép definíciójára.\\
A $H \subseteq B $ halmaz $R$ reláció szerinti \textit{inverz}képe:
$$ R^{(-1)}(H) ::= \{ a \in A | R(a) \cap H \ne \varnothing \}$$
A $H \subseteq B $ halmaz $R$ reláció szerinti \textit{ős}képe:
$$ R^{-1}(H) ::= \{ a \in A | R(a) \subseteq H \}$$

Meggondolva látható, hogy az \textit{inverzkép} megengedőbb, hisz csak annyit kér, hogy egy adott elemhez \textit{létezzen} $H$-beli elem az $R$ hozzárendelésben, az \textit{őskép} viszont megköveteli, hogy \textit{minden} ilyen elem a $H$ halmazban legyen.

Legyen $R \subseteq A \times \mathbb{L}$ logikai reláció, $R$ igazsághalmaza ekkor:
$$  \lceil R \rceil ::= R^{-1}(\{igaz\}) \text{ azaz: } \lceil R \rceil = \{a \in \mathcal{D}_R | R(a) \subseteq \{igaz\} \} $$
Az igazsághalmazt tehát az $\{igaz\}$ halmazra vett őskép szerint definiáljuk.\\
Ha inverzképet számolunk, akkor juthatunk a \textit{gyenge igazsághalmaz} fogalmához:
$$  \lfloor R \rfloor ::= R^{(-1)}(\{igaz\}) \text{ azaz: } \lfloor R \rfloor = \{a \in \mathcal{D}_R | R(a) \cap \{igaz\} \ne \varnothing \} $$

A későbbiekben nagyban megkönnyíti a dolgunkat, ha bevezetjük az \textit{azonosan igaz}, és az \textit{azonosan hamis} logikai függvényeket.
$$Igaz: A \rightarrow \mathbb{L}: \forall a \in A: Igaz(a) = \{igaz\} $$
$$Hamis: A \rightarrow \mathbb{L}: \forall a \in A: Hamis(a) = \{hamis\} $$
Könnyű meggondolni, hogy ekkor $\lceil Igaz \rceil = A \text{ és } \lceil Hamis \rceil = \varnothing $.\\
Az igazsághalmazzal kapcsolatban fontos megemlíteni néhány tulajdonságot, melyeket a későbbiekben kihasználunk.\\
\\
Legyenek $P$, $Q \subseteq A \times \mathbb{L}$, ekkor:
\begin{itemize}
	\item $ \lceil P \land Q \rceil = \lceil P \rceil \cap \lceil Q \rceil $
	\item $ \lceil P \lor Q \rceil = \lceil P \rceil \cup \lceil Q \rceil  $
	\item $	\lceil \neg P \rceil = A \setminus \lceil P \rceil  $
	\item $\lceil P \Rightarrow Q \rceil = \lceil \neg P \lor Q \rceil = (A \setminus P) \cup \lceil Q \rceil $
	\item $ P \Rightarrow Q = \lceil P \rceil \subseteq \lceil Q \rceil $
\end{itemize}

Egyszerűbben megfogalmazhatóak állítások, ha tudjuk, hogy $A \Rightarrow B$. Ekkor ugyanis:
\begin{itemize}
	\item $A \lor B = B$
	\item $A \land B = A$
\end{itemize}
Nézzünk erre egy példát, legyenek $A$, $B: \mathbb{N} \times \mathbb{L}$ úgy, hogy:\\
$\lceil A \rceil := $\{10-nél nagyobb szám\} és\\
$\lceil B \rceil := $ \{pozitív szám\}.\\
Világos, hogy $A \Rightarrow B$, hiszen ha egy egész szám 10-nél nagyobb, akkor pozitív.
Az $A \lor B$ állítást úgy fogalmazhatjuk meg, hogy azokat az egész számokat keressük, melyek 10-nél nagyobbak, \textbf{vagy} pozitívak. Érződik, hogy a \textit{vagy} kapcsolat miatt a gyengébb feltétellel is megelégszünk, így a bővebb halmaz, azaz a pozitív számok halmazát kapjuk $(=B)$. Ha azonban a 10-nél nagyobb \textbf{és} pozitív számokra vagyunk kíváncsiak, akkor a szigorítás miatt a szűkebb halmazt kapjuk, tehát a 10-nél nagyobb számokat kell vizsgálnunk $(=A)$.

\subsection{Program}

Röviden tekintsük át, hogy a Fóthi\textsuperscript{\cite{fothi_biblia}}-Horváth - féle modellben hogyan is definiáltuk a programot és annak hatásrelációját.

Jelölje $A^*$ az $A$ elemeiből képzett véges, $A^\infty$ pedig a végtelen sorozatokat. A későbbiekben $A^{**}$ jelenti az $A^* \cup A^{\infty}$ halmazt, azaz a véges és végtelen sorozatok halmazát. Ha alaphalmaznak a természetes számokat választjuk, akkor az $<1, 5, 3, 2> \in A^*$ egy véges, míg az $<1, 2, 3, 4, ...> \in A^{\infty}$ végtelen sorozatot jelöl.\\

\textit{Utasítás} vagy \textit{program} alatt egy olyan \sprog relációt értünk, melyre:
\begin{enumerate}
	\item $\mathcal{D}_S = A$
	\item $\forall a \in A : \forall \alpha \in S(a) : |\alpha|\ne 0 \land  \alpha_1 = a $
	\item $(\alpha \in \mathcal{R}_S \land \alpha \in A^*  ) \Rightarrow (\forall i   (1 \le i < |\alpha|): \alpha_i \ne \alpha_{i+1} )$
	\item $(\alpha \in \mathcal{R}_S \land \alpha \in A^{\infty}) \Rightarrow (\forall i \in \mathbb{N} (\alpha_{i} = \alpha_{i+1} \rightarrow (\forall k \in \mathbb{N^+}): \alpha_{i} = \alpha_{i+k})))$
\end{enumerate}
A fenti definíció a \textit{működés} fogalmát próbálja absztrakt módon szemléltetni. A négy pont jól jellemzi a programot: elsőként szeretnénk, ha a program minden állapottér-beli pontban értelmezve lenne (azaz a program mindenhonnan el tud indulni).\\
Második pontban azt fogalmazzuk meg, hogy egy sorozat a működése teljes történetét írja le, kezdve a kiindulási állapottal.\\
A harmadik pontunk a \textit{redukáltságra} vonatkozik: ha véges hosszú sorozattal dolgozunk, akkor egymás után kétszer ne szerepelhessen ugyanaz az elem (hiszen az nem egy jó véges program, amelyik úgy lép egy következő állapotba, hogy nem történt állapotváltozás - ez a megfogalmazáson is érződik).\\
A negyedik pont a végtelen programra utal: ha egy program futása nem fejeződik be (végtelen ciklus, stb.), akkor ezt a hozzárendelt sorozatban úgy jelzi, hogy egy adott ponttól kezdve nem történik állapotváltozás, folyton ugyan abban az állapotban ragad (pl. $S(4) = <4, 3, 2, 1, 0, 0, 0, 0, 0, 0, ...>$) \\


Egy \sprog program hatásrelációja, vagy programfüggvénye az a $p(S) \subseteq A \times A$ reláció, melyre:
\begin{enumerate}
	\item $ \mathcal{D}_{p(S)} = \{a \in A | S(a) \subseteq A^* \} $
	\item $ p(S)(a) = \{ b \in  A | \exists \alpha \in S(a) : \tau(\alpha) = b  \}$
\end{enumerate}
ahol $\tau: A^* \rightarrow A; \tau(\alpha) ::= \alpha_{|\alpha|}$, azaz a \textit{tau} függvény egy véges sorozathoz annak utolsó tagját rendeli.

A programfüggvényt tehát csak olyan pontokban definiáljuk, ahol a program \textit{megáll}, azaz véges sorozatot rendel, a hozzárendelési szabály pedig az, ahová a program eljut, tehát az adott sorozatok utolsó eleme.

\subsection{Leggyengébb előfeltétel}
Érezhető, hogy a fenti definíciókkal történő számolások nagyon nehézzé fogják tenni a későbbiekben a feladatok és az azt megoldó programok közötti kapcsolat megteremtését, ezért bevezetünk egy új fogalmat, a \textit{leggyengébb előfeltétel}t.
\paragraph{}
Legyen \sprog program, $R: A \rightarrow \mathbb{L}$ állítás. Az $S$ program $R$ utófeltételhez tartozó \textit{leggyengébb előfeltétele} az az $lf(S,R): A \times \mathbb{L}$ \textbf{függvény}, melyre:
$$ \lceil lf(S,R) \rceil = \{ A \in \mathcal{D}_{p(S)} | p(S)(a) \subseteq \lceil R \rceil \} $$
Az \textit{lf} tehát egy olyan függvény, mely pontosan azokhoz a pontokhoz rendel igazat, melyből elindítva az $S$ programot az biztosan megáll, és az összes ilyen állapotban az $R$ tulajdonság teljesül. Magának a függvénynek a definícióját legtöbbször nehéz megadni, de az igazsághalmazát könnyedén kifejezhetjük. Az igazsághalmaz definícióját, a kompozíció és az őskép tulajdonságait felhasználva kapjuk, hogy:
$$\lceil lf(S,R)\rceil = \lceil R \circ p(S) \rceil.$$
Az \textit{lf}-et tehát az utófeltételbe helyettesítés módszerével tudjuk kifejezni (ennek bizonyítása megtalálható a \textit{tankönyv}\textsuperscript{\cite{fothi_biblia}} 44-ik oldalán, a 3.1-es definíciónál).

A későbbiekben több alaptulajdonságra is szükségünk lesz, ha az \textit{lf}-fel akarunk számolni. Nézzük ezeket:
\paragraph{}
Legyen \sprog{} program, $Q,R: A \rightarrow \mathbb{L}$ állítások. Ekkor:
\begin{enumerate}
	\item $lf(S, Hamis) = Hamis$ (csoda kizárásának elve),
	\item Ha $Q \Rightarrow R$, akkor $lf(S,Q) \Rightarrow lf(S,R)$ (monotonitás),
	\item $lf(S,Q) \lor lf(S,R) \Rightarrow lf(S, Q\lor R)$ (gyenge additivitás),
	\item $lf(S,Q) \land lf(S,R) = lf(S, Q\land R)$ (multiplikativitás)
\end{enumerate}
A bizonyításokat szintén a jegyzetben lehet olvasni.
\paragraph{Kiszámítása:}
Az \textit{lf} kiszámolását a már fentebb említett utófeltételbe helyettesítés módszerével tudjuk megtenni.

Az \textbf{egyszerű értékadás}ok során ez a következőt jelenti:
$$lf(x := y, R) = R^{x \leftarrow y } $$
Például az $S = \{x:=3\}, R = (1 \le x \le 5)$ esetben:\\
$lf(S,R) = lf(\{x:=3\}, (1 \le x \le 5)) = R^{x \leftarrow y} = (1 \le x \le 5)^{x \leftarrow 3} = (1 \le 3 \le 5)$.
Az $S$ programot tehát olyan állapotokból tudjuk elindítani biztonságosan úgy, hogy $R$-be érkezzen, melyre teljesül az, hogy $1 \le 3 \le 5 \equiv igaz$, azaz tetszőleges pontból indítva helyesen működő programot kaphatunk.

\textbf{Feltételes értékadás} esetén figyelembe kell venni a feltételt is, hiszen ha ez nem teljesül, abban az esetben nem kell az értékadást végrehajtanunk.
$$lf(\{x:=y, \text{ha } \pi\}, R) = (\pi \rightarrow R^{x \leftarrow y}) \land (\neg \pi \rightarrow R^{SKIP})$$

\textbf{Szimultán értékadás} során egyszerre hajtjuk végre az adott értékadásokat:
$$lf(\{x_1, ..., x_n := y_1, ..., y_n\}, R) = lf(\{ \mathop{\parallel}_{i=1}^{n} x_i := y_i \}, R) = R^{\substack{ x_1 \leftarrow y_1 \\ ... \\ x_n \leftarrow y_n }}$$

A \textbf{feltételes szimultán értékadás} kiszámításának módja ezek után egyértelműen megállapítható az előzőek alapján:
$$lf(\{x_1, ..., x_n := y_1, ..., y_n, \text{ha } \pi \}, R) = lf(\{ \mathop{\parallel}_{i=1}^{n} x_i := y_i, \text{ha }\pi \}, R) = $$
$$= (\pi \rightarrow R^{\substack{ x_1 \leftarrow y_1 \\ ... \\ x_n \leftarrow y_n }}) \land (\neg \pi \rightarrow R^{SKIP})$$

\newpage

\section{Megoldások}
	~\ref{etkezo-filo} - \nameref{etkezo-filo}
	\begin{itemize}
		\item $FP \Rightarrow (\forall i: \neg f(i).e)$
		\item $f(i).o \vartriangleright \bot$
	\end{itemize}
	~\ref{moziterem-feladat} - \nameref{moziterem-feladat}
	\begin{itemize}
		\item $n(i).a \hookrightarrow n(i).f $
		\item $n(i).t \hookrightarrow n(i).f$
		\item $FP \Rightarrow \forall i : n(i).h$
		\item $n(i).a \vartriangleright (n(i).j \lor n(i).b)$
		\item $n(i).f \mapsto n(i).h$
		\item $(\forall i: n(i).f \Rightarrow n(i).t) \in inv$
		\item $n(i).h \vartriangleright \bot$
	\end{itemize}

\begin{thebibliography}{9}
\bibitem{orsi_jegyzet}
\raggedright
dr. Horváth Zoltán: Párhuzamos és elosztott programozás (http://people.inf.elte.hu/hz/parh/jegyzet.ps)

\bibitem{fothi_biblia}
Fóthi Ákos: Bevezetés a programozáshoz (http://bzsr.web.elte.hu/progmod2/konyv.pdf)

\end{thebibliography}
\end{document}